package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var array = [5]int32{2, 4, 6, 8, 10} // создаем массив
	var wg sync.WaitGroup                //создаем waitgroup, чтобы дождаться выполнения всех горутин

	var sum int32
	for _, j := range array { // итерируемся по значению
		wg.Add(1) //в начале каждого цикла прибавляем единичку в wg
		go func(j int32) {
			atomic.AddInt32(&sum, j*j) //атомарная операция за один тик прибавляем к сумме квадрат значения массива. Позволяет избежать гонки данных.
			wg.Done()                  //после отработки горутины убавляем единичку из wg
		}(j) //явно передаем значение в горутину, так как время создания горутины больше времени прохождения итерации цикла.
	}
	wg.Wait()        //ждем, когда wg == 0
	fmt.Println(sum) //выводим сумму квадратов в stdout
}

//Про атомики:
//Во время выполнения такой операции над переменной, ни один поток не может наблюдать изменение наполовину завершенным(переключения горутин не будет).
//Атомарная загрузка гарантирует, что переменная будет загружена целиком в один момент времени.
//Неатомарные операции не дают такой гарантии.
